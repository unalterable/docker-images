worker_processes 1;

events {
    worker_connections 1024;
}

http {
    log_format main '[$time_local] $remote_addr "$request" $status $body_bytes_sent';
    access_log /var/log/openresty/access.log main;
    error_log /var/log/openresty/error.log;

    limit_req_zone $binary_remote_addr zone=login_limit:10m rate=5r/m;
    limit_req_zone $binary_remote_addr zone=refresh_limit:10m rate=10r/m;

    map $http_upgrade $connection_upgrade {
        default upgrade;
        '' close;
    }

    init_by_lua_block {
        local bcrypt = require "bcrypt"
        local sha256 = require "resty.sha256"
        local str = require "resty.string"

        local HTPASSWD = "/etc/nginx/.htpasswd"
        local SESSION_SECRET = "/etc/nginx/secrets/session_secret"
        local REFRESH_SECRET = "/etc/nginx/secrets/refresh_secret"
        local SESSION_MAX_AGE = 86400
        local REFRESH_MAX_AGE = 604800

        function read_file(path)
            local f = io.open(path, "r")
            if not f then return nil end
            local c = f:read("*all"):gsub("^%s*(.-)%s*$", "%1")
            f:close()
            return c
        end

        function secure_compare(a, b)
            if not a or not b or #a ~= #b then return false end
            local r = 0
            for i = 1, #a do r = bit.bor(r, bit.bxor(a:byte(i), b:byte(i))) end
            return r == 0
        end

        function sign(secret, data)
            local h = sha256:new()
            h:update(secret .. data)
            return str.to_hex(h:final())
        end

        function get_user_hash(username)
            local f = io.open(HTPASSWD, "r")
            if not f then return nil end
            for line in f:lines() do
                local u, h = line:match("^([^:]+):(.+)$")
                if u == username then f:close() return h end
            end
            f:close()
            return nil
        end

        function clear_cookie()
            ngx.header["Set-Cookie"] = "proxy_session=; Path=/; HttpOnly; Secure; SameSite=Strict; Max-Age=0"
        end

        function set_cookie(username)
            local secret = read_file(SESSION_SECRET)
            if not secret then return nil end
            local ts = ngx.now()
            local val = username .. ":" .. ts .. ":" .. sign(secret, username .. ":" .. ts)
            ngx.header["Set-Cookie"] = "proxy_session=" .. val .. "; Path=/; HttpOnly; Secure; SameSite=Strict; Max-Age=" .. SESSION_MAX_AGE
            return val
        end

        function check_cookie()
            local c = ngx.var.cookie_proxy_session
            if not c or c == "" then return nil end
            local user, ts, sig = c:match("^([^:]+):([^:]+):([^:]+)$")
            if not user then clear_cookie() return nil end
            local secret = read_file(SESSION_SECRET)
            if not secure_compare(sig, sign(secret, user .. ":" .. ts)) then clear_cookie() return nil end
            if ngx.now() - tonumber(ts) > SESSION_MAX_AGE then clear_cookie() return nil end
            return user
        end

        function create_refresh(username)
            local secret, hash = read_file(REFRESH_SECRET), get_user_hash(username)
            if not secret or not hash then return nil end
            local ts = ngx.now()
            return username .. ":" .. ts .. ":" .. sign(secret, username .. ":" .. ts .. ":" .. hash)
        end

        function check_refresh(token)
            local user, ts, sig = token:match("^([^:]+):([^:]+):([^:]+)$")
            if not user then return nil, "Invalid format" end
            local hash = get_user_hash(user)
            if not hash then return nil, "User not found" end
            local secret = read_file(REFRESH_SECRET)
            if not secure_compare(sig, sign(secret, user .. ":" .. ts .. ":" .. hash)) then return nil, "Invalid signature" end
            if ngx.now() - tonumber(ts) > REFRESH_MAX_AGE then return nil, "Expired" end
            return user
        end

        function check_basic_auth()
            local h = ngx.var.http_authorization
            if not h then return nil end
            local enc = h:match("^Basic%s+(.+)$")
            if not enc then return nil end
            local dec = ngx.decode_base64(enc)
            if not dec then return nil end
            local user, pass = dec:match("^([^:]+):(.*)$")
            if not user then return nil end
            local hash = get_user_hash(user)
            if not hash then return nil end
            local ok, valid = pcall(bcrypt.verify, pass, hash)
            return (ok and valid) and user or nil
        end

        function require_auth()
            local user = check_cookie()
            if user then ngx.req.set_header("X-Proxy-User", user) return end

            if ngx.var.http_authorization then
                user = check_basic_auth()
                if user then ngx.req.set_header("X-Proxy-User", user) return end
                ngx.status = 401
                ngx.say("Invalid credentials")
                return ngx.exit(401)
            end

            ngx.header["Location"] = "/proxy-login?redirect=" .. ngx.escape_uri(ngx.var.request_uri)
            return ngx.exit(303)
        end

        _G.set_cookie, _G.check_cookie, _G.clear_cookie = set_cookie, check_cookie, clear_cookie
        _G.create_refresh, _G.check_refresh = create_refresh, check_refresh
        _G.check_basic_auth, _G.require_auth = check_basic_auth, require_auth
        _G.get_user_hash = get_user_hash
    }

    # HTTP -> HTTPS
    server {
        listen 80;
        location /.well-known/acme-challenge/ { root /var/www; }
        location / { return 301 https://$host$request_uri; }
    }

    # HTTPS
    server {
        listen 443 ssl;
        server_name localhost;

        ssl_certificate /etc/nginx/certs/server.crt;
        ssl_certificate_key /etc/nginx/certs/server.key;
        ssl_protocols TLSv1.2 TLSv1.3;
        ssl_prefer_server_ciphers on;
        ssl_ciphers ECDHE-ECDSA-AES128-GCM-SHA256:ECDHE-RSA-AES128-GCM-SHA256:ECDHE-ECDSA-AES256-GCM-SHA384:ECDHE-RSA-AES256-GCM-SHA384:ECDHE-ECDSA-CHACHA20-POLY1305:ECDHE-RSA-CHACHA20-POLY1305:DHE-RSA-AES128-GCM-SHA256:DHE-RSA-AES256-GCM-SHA384;
        ssl_session_cache shared:SSL:10m;
        ssl_session_timeout 10m;
        ssl_session_tickets off;
        add_header Strict-Transport-Security "max-age=31536000; includeSubDomains" always;

        location /.well-known/acme-challenge/ { root /var/www; }
        location = /proxy-login { default_type text/html; alias /etc/nginx/html/login.html; }

        location = /proxy-auth {
            limit_req zone=login_limit burst=3 nodelay;
            limit_req_status 429;
            content_by_lua_block {
                local user = check_basic_auth()
                if not user then
                    ngx.status = 401
                    ngx.header["Content-Type"] = "application/json"
                    return ngx.say('{"error":"Invalid credentials"}')
                end
                set_cookie(user)
                ngx.header["Content-Type"] = "application/json"
                ngx.header["Cache-Control"] = "no-store"
                ngx.say(require("cjson").encode({refresh_token = create_refresh(user)}))
            }
        }

        location = /proxy-refresh {
            limit_req zone=refresh_limit burst=5 nodelay;
            limit_req_status 429;
            content_by_lua_block {
                ngx.req.read_body()
                local body = ngx.req.get_body_data()
                if not body then ngx.status = 400 return ngx.say('{"error":"No body"}') end
                local ok, data = pcall(require("cjson").decode, body)
                if not ok or not data.refresh_token then ngx.status = 400 return ngx.say('{"error":"Invalid request"}') end
                local user, err = check_refresh(data.refresh_token)
                if not user then ngx.status = 401 return ngx.say('{"error":"' .. err .. '"}') end
                set_cookie(user)
                ngx.header["Content-Type"] = "application/json"
                ngx.header["Cache-Control"] = "no-store"
                ngx.say('{"status":"ok"}')
            }
        }

        location / {
            access_by_lua_block { require_auth() }
            proxy_pass $UPSTREAM_HOST;
            proxy_set_header Host $host;
            proxy_set_header X-Real-IP $remote_addr;
            proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
            proxy_set_header X-Forwarded-Proto $scheme;
            proxy_http_version 1.1;
            proxy_set_header Upgrade $http_upgrade;
            proxy_set_header Connection $connection_upgrade;
            proxy_read_timeout 86400s;
            proxy_send_timeout 86400s;
            proxy_buffering off;
        }
    }
}