worker_processes 1;

events {
    worker_connections 1024;
}

http {
    log_format main '[$time_local] "$remote_addr" "$remote_user" "$request" "$status" "$body_bytes_sent" "$http_referer" "$http_user_agent" "$http_x_forwarded_for"';
    log_format unauthorized_log '[$time_local] "$remote_addr" "$remote_user" "$request" "$status" "$body_bytes_sent" "$http_referer" "$http_user_agent" "$http_x_forwarded_for"';
    access_log /var/log/openresty/access.log main;
    error_log /var/log/openresty/error.log;

    limit_req_zone $binary_remote_addr zone=login_limit:10m rate=5r/m;
    limit_req_zone $binary_remote_addr zone=refresh_limit:10m rate=10r/m;

    map $http_upgrade $connection_upgrade {
        default upgrade;
        '' close;
    }

    map $http_authorization $has_basic_auth {
        default 0;
        "~^Basic " 1;
    }

    init_by_lua_block {
        function read_secret_file(path)
            local file = io.open(path, "r")
            if not file then return nil end
            local content = file:read("*all")
            file:close()
            return content:gsub("^%s*(.-)%s*$", "%1")
        end
        
        function secure_compare(a, b)
            if #a ~= #b then return false end
            local result = 0
            for i = 1, #a do
                result = bit.bor(result, bit.bxor(string.byte(a, i), string.byte(b, i)))
            end
            return result == 0
        end
        
        function compute_signature(secret, data)
            local resty_sha256 = require "resty.sha256"
            local str = require "resty.string"
            local sha256 = resty_sha256:new()
            sha256:update(secret .. data)
            return str.to_hex(sha256:final())
        end
        
        function read_user_hash(username)
            local file = io.open("/etc/nginx/.htpasswd", "r")
            if not file then return nil end
            for line in file:lines() do
                local user, hash = line:match("^([^:]+):(.+)$")
                if user == username then
                    file:close()
                    return hash
                end
            end
            file:close()
            return nil
        end
        
        function clear_session_cookie()
            ngx.header["Set-Cookie"] = "proxy_session=; Path=/; HttpOnly; Secure; SameSite=Strict; Max-Age=0"
        end
        
        _G.read_secret_file = read_secret_file
        _G.secure_compare = secure_compare
        _G.compute_signature = compute_signature
        _G.read_user_hash = read_user_hash
        _G.clear_session_cookie = clear_session_cookie
        _G.SESSION_MAX_AGE = 86400
        _G.REFRESH_MAX_AGE = 604800
    }

    server {
        listen 80;
        server_name localhost;

        location /.well-known/acme-challenge/ {
            access_log /var/log/openresty/unauthorized.log unauthorized_log;
            root /var/www;
            try_files $uri =404;
        }

        location / {
            return 301 https://$host$request_uri;
        }
    }

    server {
        listen 443 ssl;
        server_name localhost;

        ssl_certificate /etc/nginx/certs/server.crt;
        ssl_certificate_key /etc/nginx/certs/server.key;
        ssl_protocols TLSv1.2 TLSv1.3;
        ssl_prefer_server_ciphers on;
        ssl_ciphers ECDHE-ECDSA-AES128-GCM-SHA256:ECDHE-RSA-AES128-GCM-SHA256:ECDHE-ECDSA-AES256-GCM-SHA384:ECDHE-RSA-AES256-GCM-SHA384:ECDHE-ECDSA-CHACHA20-POLY1305:ECDHE-RSA-CHACHA20-POLY1305:DHE-RSA-AES128-GCM-SHA256:DHE-RSA-AES256-GCM-SHA384;
        ssl_session_cache shared:SSL:10m;
        ssl_session_timeout 10m;
        ssl_session_tickets off;
        add_header Strict-Transport-Security "max-age=31536000; includeSubDomains" always;

        location /.well-known/acme-challenge/ {
            auth_basic off;
            root /var/www;
            access_log /var/log/openresty/unauthorized.log unauthorized_log;
            try_files $uri =404;
        }

        location = /proxy-login {
            access_log /var/log/openresty/unauthorized.log unauthorized_log;
            default_type text/html;
            alias /etc/nginx/html/login.html;
        }

        location = /proxy-auth {
            limit_req zone=login_limit burst=3 nodelay;
            limit_req_status 429;

            content_by_lua_block {
                -- Validate Basic Auth header
                local auth_header = ngx.var.http_authorization
                if not auth_header or not auth_header:match("^Basic%s+") then
                    ngx.status = ngx.HTTP_UNAUTHORIZED
                    ngx.header["Content-Type"] = "application/json"
                    ngx.say('{"error":"Missing or invalid Authorization header"}')
                    return
                end
                
                -- Validate credentials using internal location
                local res = ngx.location.capture("/internal-validate-basic-auth", {
                    method = ngx.HTTP_GET,
                    copy_all_vars = true
                })
                
                if res.status ~= ngx.HTTP_OK then
                    ngx.status = ngx.HTTP_UNAUTHORIZED
                    ngx.header["Content-Type"] = "application/json"
                    ngx.say('{"error":"Invalid credentials"}')
                    return
                end
                
                -- Extract username from validation response
                local cjson = require "cjson"
                local ok, data = pcall(cjson.decode, res.body)
                if not ok or not data.username then
                    ngx.status = ngx.HTTP_INTERNAL_SERVER_ERROR
                    ngx.say('{"error":"Failed to parse username"}')
                    return
                end
                
                local username = data.username
                local timestamp = ngx.now()
                local password_hash = read_user_hash(username)
                
                if not password_hash then
                    ngx.status = ngx.HTTP_INTERNAL_SERVER_ERROR
                    ngx.say('{"error":"Failed to read credentials"}')
                    return
                end
                
                local session_secret = read_secret_file("/etc/nginx/secrets/session_secret")
                local refresh_secret = read_secret_file("/etc/nginx/secrets/refresh_secret")
                
                local session_sig = compute_signature(session_secret, username .. ":" .. timestamp)
                local session_value = username .. ":" .. timestamp .. ":" .. session_sig
                
                local refresh_sig = compute_signature(refresh_secret, username .. ":" .. timestamp .. ":" .. password_hash)
                local refresh_value = username .. ":" .. timestamp .. ":" .. refresh_sig
                
                ngx.header["Set-Cookie"] = "proxy_session=" .. session_value .. "; Path=/; HttpOnly; Secure; SameSite=Strict; Max-Age=" .. _G.SESSION_MAX_AGE
                ngx.header["Cache-Control"] = "no-store"
                ngx.header["Content-Type"] = "application/json"
                
                ngx.say(cjson.encode({refresh_token = refresh_value}))
            }
        }

        location = /proxy-refresh {
            limit_req zone=refresh_limit burst=5 nodelay;
            limit_req_status 429;
            
            content_by_lua_block {
                ngx.req.read_body()
                local body = ngx.req.get_body_data()
                
                if not body then
                    ngx.status = ngx.HTTP_BAD_REQUEST
                    ngx.say('{"error":"No request body"}')
                    return
                end
                
                local cjson = require "cjson"
                local ok, data = pcall(cjson.decode, body)
                if not ok or not data.refresh_token then
                    ngx.status = ngx.HTTP_BAD_REQUEST
                    ngx.say('{"error":"Invalid request"}')
                    return
                end
                
                local username, issued_timestamp, signature = data.refresh_token:match("^([^:]+):([^:]+):([^:]+)$")
                if not username or not issued_timestamp or not signature then
                    ngx.status = ngx.HTTP_UNAUTHORIZED
                    ngx.say('{"error":"Invalid token format"}')
                    return
                end
                
                local password_hash = read_user_hash(username)
                if not password_hash then
                    ngx.log(ngx.WARN, "User no longer exists: ", username)
                    ngx.status = ngx.HTTP_UNAUTHORIZED
                    ngx.say('{"error":"User not found"}')
                    return
                end
                
                local refresh_secret = read_secret_file("/etc/nginx/secrets/refresh_secret")
                local expected_sig = compute_signature(refresh_secret, username .. ":" .. issued_timestamp .. ":" .. password_hash)
                
                if not secure_compare(signature, expected_sig) then
                    ngx.log(ngx.WARN, "Invalid refresh token signature for user: ", username)
                    ngx.status = ngx.HTTP_UNAUTHORIZED
                    ngx.say('{"error":"Invalid signature"}')
                    return
                end
                
                local token_age = ngx.now() - tonumber(issued_timestamp)
                if token_age > _G.REFRESH_MAX_AGE then
                    ngx.log(ngx.INFO, "Expired refresh token for user: ", username)
                    ngx.status = ngx.HTTP_UNAUTHORIZED
                    ngx.say('{"error":"Token expired"}')
                    return
                end
                
                local session_secret = read_secret_file("/etc/nginx/secrets/session_secret")
                local new_timestamp = ngx.now()
                local session_sig = compute_signature(session_secret, username .. ":" .. new_timestamp)
                local session_value = username .. ":" .. new_timestamp .. ":" .. session_sig
                
                ngx.header["Set-Cookie"] = "proxy_session=" .. session_value .. "; Path=/; HttpOnly; Secure; SameSite=Strict; Max-Age=" .. _G.SESSION_MAX_AGE
                ngx.header["Cache-Control"] = "no-store"
                ngx.header["Content-Type"] = "application/json"
                ngx.say('{"status":"ok"}')
            }
        }

        location = /proxy-check-session {
            internal;
            content_by_lua_block {
                local cookie = ngx.var.cookie_proxy_session
                if not cookie or cookie == "" then
                    ngx.exit(ngx.HTTP_UNAUTHORIZED)
                    return
                end
                
                local username, timestamp, signature = cookie:match("^([^:]+):([^:]+):([^:]+)$")
                if not username or not timestamp or not signature then
                    clear_session_cookie()
                    ngx.exit(ngx.HTTP_UNAUTHORIZED)
                    return
                end
                
                local secret = read_secret_file("/etc/nginx/secrets/session_secret")
                local expected_sig = compute_signature(secret, username .. ":" .. timestamp)
                
                if not secure_compare(signature, expected_sig) then
                    ngx.log(ngx.WARN, "Invalid session signature for user: ", username, " - clearing cookie")
                    clear_session_cookie()
                    ngx.exit(ngx.HTTP_UNAUTHORIZED)
                    return
                end
                
                local session_age = ngx.now() - tonumber(timestamp)
                if session_age > _G.SESSION_MAX_AGE then
                    ngx.log(ngx.INFO, "Expired session for user: ", username, " - clearing cookie")
                    clear_session_cookie()
                    ngx.exit(ngx.HTTP_UNAUTHORIZED)
                    return
                end
                
                ngx.req.set_header("X-Proxy-User", username)
                ngx.exit(ngx.HTTP_OK)
            }
        }

        location / {
            access_by_lua_block {
                -- Check if Basic Auth header is present
                if ngx.var.has_basic_auth == "1" then
                    -- Basic Auth flow: validate by making internal subrequest
                    -- The subrequest will inherit the Authorization header
                    local res = ngx.location.capture("/internal-validate-basic-auth", {
                        method = ngx.HTTP_GET,
                        copy_all_vars = true
                    })
                    
                    if res.status == ngx.HTTP_OK then
                        -- Extract username from the response
                        local cjson = require "cjson"
                        local ok, data = pcall(cjson.decode, res.body)
                        if ok and data.username then
                            ngx.req.set_header("X-Proxy-User", data.username)
                            ngx.log(ngx.INFO, "Basic Auth successful for user: ", data.username)
                            return  -- Proceed to proxy
                        end
                    end
                    
                    -- Basic Auth failed - return 401 without WWW-Authenticate header
                    -- (appropriate for URL-based auth, no browser dialog)
                    ngx.log(ngx.WARN, "Basic Auth validation failed")
                    ngx.status = ngx.HTTP_UNAUTHORIZED
                    ngx.header["Content-Type"] = "text/plain"
                    ngx.say("Unauthorized")
                    return ngx.exit(ngx.HTTP_UNAUTHORIZED)
                end
                
                -- Cookie flow: no Basic Auth header present
                local cookie = ngx.var.cookie_proxy_session
                if not cookie or cookie == "" then
                    ngx.log(ngx.INFO, "No session cookie, redirecting to login: ", ngx.var.request_uri)
                    return ngx.redirect("/proxy-login?redirect=" .. ngx.escape_uri(ngx.var.request_uri), ngx.HTTP_SEE_OTHER)
                end
                
                -- Validate session cookie
                local username, timestamp, signature = cookie:match("^([^:]+):([^:]+):([^:]+)$")
                if not username or not timestamp or not signature then
                    clear_session_cookie()
                    ngx.log(ngx.INFO, "Invalid cookie format, redirecting to login")
                    return ngx.redirect("/proxy-login?redirect=" .. ngx.escape_uri(ngx.var.request_uri), ngx.HTTP_SEE_OTHER)
                end
                
                local secret = read_secret_file("/etc/nginx/secrets/session_secret")
                local expected_sig = compute_signature(secret, username .. ":" .. timestamp)
                
                if not secure_compare(signature, expected_sig) then
                    ngx.log(ngx.WARN, "Invalid session signature for user: ", username, " - redirecting to login")
                    clear_session_cookie()
                    return ngx.redirect("/proxy-login?redirect=" .. ngx.escape_uri(ngx.var.request_uri), ngx.HTTP_SEE_OTHER)
                end
                
                local session_age = ngx.now() - tonumber(timestamp)
                if session_age > _G.SESSION_MAX_AGE then
                    ngx.log(ngx.INFO, "Expired session for user: ", username, " - redirecting to login")
                    clear_session_cookie()
                    return ngx.redirect("/proxy-login?redirect=" .. ngx.escape_uri(ngx.var.request_uri), ngx.HTTP_SEE_OTHER)
                end
                
                -- Valid session
                ngx.req.set_header("X-Proxy-User", username)
            }

            proxy_pass $UPSTREAM_HOST;
            proxy_set_header Host $host;
            proxy_set_header X-Real-IP $remote_addr;
            proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
            proxy_set_header X-Forwarded-Proto $scheme;
            proxy_http_version 1.1;
            proxy_set_header Upgrade $http_upgrade;
            proxy_set_header Connection $connection_upgrade;
            proxy_read_timeout 86400s;
            proxy_send_timeout 86400s;
            proxy_buffering off;
        }

        location = /internal-validate-basic-auth {
            internal;
            # This location validates Basic Auth credentials without exposing
            # the WWW-Authenticate header to the browser (internal subrequest only)
            auth_basic "Validation";
            auth_basic_user_file /etc/nginx/.htpasswd;
            
            content_by_lua_block {
                -- If we reach here, auth_basic succeeded
                local cjson = require "cjson"
                ngx.header["Content-Type"] = "application/json"
                ngx.say(cjson.encode({username = ngx.var.remote_user}))
            }
        }
    }
}