worker_processes 1;

events {
    worker_connections 1024;
}

http {
    log_format main '[$time_local] "$remote_addr" "$remote_user" "$request" "$status" "$body_bytes_sent" "$http_referer" "$http_user_agent" "$http_x_forwarded_for"';
    log_format unauthorized_log '[$time_local] "$remote_addr" "$remote_user" "$request" "$status" "$body_bytes_sent" "$http_referer" "$http_user_agent" "$http_x_forwarded_for"';
    access_log /var/log/openresty/access.log main;
    error_log /var/log/openresty/error.log;

    # Rate limiting for login attempts
    limit_req_zone $binary_remote_addr zone=login_limit:10m rate=5r/m;
    limit_req_zone $binary_remote_addr zone=refresh_limit:10m rate=10r/m;

    # Map for WebSocket upgrade
    map $http_upgrade $connection_upgrade {
        default upgrade;
        '' close;
    }

    # Check if request has Basic Auth header
    map $http_authorization $has_basic_auth {
        default 0;
        "~^Basic " 1;
    }

    # Helper function to read secrets from files
    init_by_lua_block {
        function read_secret_file(path)
            local file = io.open(path, "r")
            if not file then
                return nil
            end
            local content = file:read("*all")
            file:close()
            return content:gsub("^%s*(.-)%s*$", "%1")  -- trim whitespace
        end
        
        -- Store as global functions
        _G.read_secret_file = read_secret_file
        _G.SESSION_MAX_AGE = 86400  -- 24 hours
        _G.REFRESH_MAX_AGE = 604800  -- 7 days
    }

    # =====================================================
    # HTTP SERVER - Redirect to HTTPS
    # =====================================================
    server {
        listen 80;
        server_name localhost;

        location /.well-known/acme-challenge/ {
            access_log /var/log/openresty/unauthorized.log unauthorized_log;
            root /var/www;
            try_files $uri =404;
        }

        location / {
            return 301 https://$host$request_uri;
        }
    }

    # =====================================================
    # HTTPS SERVER - Main authentication and proxy
    # =====================================================
    server {
        listen 443 ssl;
        server_name localhost;

        ssl_certificate /etc/nginx/certs/server.crt;
        ssl_certificate_key /etc/nginx/certs/server.key;
        ssl_protocols TLSv1.2 TLSv1.3;
        ssl_prefer_server_ciphers on;
        ssl_ciphers ECDHE-ECDSA-AES128-GCM-SHA256:ECDHE-RSA-AES128-GCM-SHA256:ECDHE-ECDSA-AES256-GCM-SHA384:ECDHE-RSA-AES256-GCM-SHA384:ECDHE-ECDSA-CHACHA20-POLY1305:ECDHE-RSA-CHACHA20-POLY1305:DHE-RSA-AES128-GCM-SHA256:DHE-RSA-AES256-GCM-SHA384;
        ssl_session_cache shared:SSL:10m;
        ssl_session_timeout 10m;
        ssl_session_tickets off;
        add_header Strict-Transport-Security "max-age=31536000; includeSubDomains" always;

        # Let's Encrypt - no auth
        location /.well-known/acme-challenge/ {
            auth_basic off;
            allow all;
            root /var/www;
            access_log /var/log/openresty/unauthorized.log unauthorized_log;
            try_files $uri =404;
        }

        # =====================================================
        # LOGIN PAGE - Served from file
        # =====================================================
        location = /proxy-login {
            default_type text/html;
            alias /etc/nginx/html/login.html;
        }

        # =====================================================
        # AUTH ENDPOINT - Validates credentials, sets session cookie and returns refresh token
        # =====================================================
        location = /proxy-auth {
            limit_req zone=login_limit burst=3 nodelay;
            limit_req_status 429;

            # Validate against .htpasswd
            auth_basic "Login";
            auth_basic_user_file /etc/nginx/.htpasswd;

            # If we get here, Basic Auth succeeded - create signed cookies and refresh token
            content_by_lua_block {
                local resty_sha256 = require "resty.sha256"
                local str = require "resty.string"
                
                local session_secret = read_secret_file("/etc/nginx/secrets/session_secret")
                local refresh_secret = read_secret_file("/etc/nginx/secrets/refresh_secret")
                local session_max_age = _G.SESSION_MAX_AGE
                local refresh_max_age = _G.REFRESH_MAX_AGE
                local username = ngx.var.remote_user
                local timestamp = ngx.now()
                
                -- Read password hash from htpasswd
                local password_hash = nil
                local file = io.open("/etc/nginx/.htpasswd", "r")
                if file then
                    for line in file:lines() do
                        local user, hash = line:match("^([^:]+):(.+)$")
                        if user == username then
                            password_hash = hash
                            break
                        end
                    end
                    file:close()
                end
                
                if not password_hash then
                    ngx.status = ngx.HTTP_INTERNAL_SERVER_ERROR
                    ngx.say('{"error":"Failed to read credentials"}')
                    return
                end
                
                -- Create session token signature
                local session_data = username .. ":" .. timestamp
                local sha256 = resty_sha256:new()
                sha256:update(session_secret .. session_data)
                local session_signature = str.to_hex(sha256:final())
                local session_cookie_value = username .. ":" .. timestamp .. ":" .. session_signature
                
                -- Create refresh token signature (includes issued timestamp AND password hash)
                local refresh_data = username .. ":" .. timestamp .. ":" .. password_hash
                sha256 = resty_sha256:new()
                sha256:update(refresh_secret .. refresh_data)
                local refresh_signature = str.to_hex(sha256:final())
                local refresh_token_value = username .. ":" .. timestamp .. ":" .. refresh_signature
                
                -- Set session cookie (HttpOnly, Secure)
                ngx.header["Set-Cookie"] = "proxy_session=" .. session_cookie_value .. "; Path=/; HttpOnly; Secure; SameSite=Strict; Max-Age=" .. session_max_age
                ngx.header["Cache-Control"] = "no-store"
                ngx.header["Content-Type"] = "application/json"
                
                -- Return refresh token in response body for localStorage
                local cjson = require "cjson"
                ngx.say(cjson.encode({refresh_token = refresh_token_value}))
            }
        }

        # =====================================================
        # REFRESH ENDPOINT - Validates refresh token, checks htpasswd, issues new session
        # =====================================================
        location = /proxy-refresh {
            limit_req zone=refresh_limit burst=5 nodelay;
            limit_req_status 429;
            
            content_by_lua_block {
                ngx.req.read_body()
                local body = ngx.req.get_body_data()
                
                if not body then
                    ngx.status = ngx.HTTP_BAD_REQUEST
                    ngx.say('{"error":"No request body"}')
                    return
                end
                
                local cjson = require "cjson"
                local ok, data = pcall(cjson.decode, body)
                if not ok then
                    ngx.status = ngx.HTTP_BAD_REQUEST
                    ngx.say('{"error":"Invalid JSON"}')
                    return
                end
                
                local refresh_token = data.refresh_token
                if not refresh_token then
                    ngx.status = ngx.HTTP_BAD_REQUEST
                    ngx.say('{"error":"Missing refresh_token"}')
                    return
                end
                
                -- Parse refresh token: username:timestamp:signature
                local username, issued_timestamp, signature = refresh_token:match("^([^:]+):([^:]+):([^:]+)$")
                if not username or not issued_timestamp or not signature then
                    ngx.status = ngx.HTTP_UNAUTHORIZED
                    ngx.say('{"error":"Invalid token format"}')
                    return
                end
                
                -- Read current password hash from htpasswd
                local password_hash = nil
                local file = io.open("/etc/nginx/.htpasswd", "r")
                if file then
                    for line in file:lines() do
                        local user, hash = line:match("^([^:]+):(.+)$")
                        if user == username then
                            password_hash = hash
                            break
                        end
                    end
                    file:close()
                end
                
                if not password_hash then
                    ngx.log(ngx.WARN, "User no longer exists: ", username)
                    ngx.status = ngx.HTTP_UNAUTHORIZED
                    ngx.say('{"error":"User not found"}')
                    return
                end
                
                -- Verify refresh token signature (includes password hash)
                local resty_sha256 = require "resty.sha256"
                local str = require "resty.string"
                local refresh_secret = read_secret_file("/etc/nginx/secrets/refresh_secret")
                
                local refresh_data = username .. ":" .. issued_timestamp .. ":" .. password_hash
                local sha256 = resty_sha256:new()
                sha256:update(refresh_secret .. refresh_data)
                local expected_signature = str.to_hex(sha256:final())
                
                -- Constant-time comparison to prevent timing attacks
                local function secure_compare(a, b)
                    if #a ~= #b then return false end
                    local result = 0
                    for i = 1, #a do
                        result = bit.bor(result, bit.bxor(string.byte(a, i), string.byte(b, i)))
                    end
                    return result == 0
                end
                
                if not secure_compare(signature, expected_signature) then
                    ngx.log(ngx.WARN, "Invalid refresh token signature for user: ", username)
                    ngx.status = ngx.HTTP_UNAUTHORIZED
                    ngx.say('{"error":"Invalid signature"}')
                    return
                end
                
                -- Check refresh token expiry
                local refresh_max_age = _G.REFRESH_MAX_AGE
                local token_age = ngx.now() - tonumber(issued_timestamp)
                if token_age > refresh_max_age then
                    ngx.log(ngx.INFO, "Expired refresh token for user: ", username)
                    ngx.status = ngx.HTTP_UNAUTHORIZED
                    ngx.say('{"error":"Token expired"}')
                    return
                end
                
                -- All checks passed (signature included password hash, so password changes invalidate tokens)
                -- Issue new session token
                local session_secret = read_secret_file("/etc/nginx/secrets/session_secret")
                local session_max_age = _G.SESSION_MAX_AGE
                local new_timestamp = ngx.now()
                
                local session_data = username .. ":" .. new_timestamp
                sha256 = resty_sha256:new()
                sha256:update(session_secret .. session_data)
                local session_signature = str.to_hex(sha256:final())
                local session_cookie_value = username .. ":" .. new_timestamp .. ":" .. session_signature
                
                -- Set new session cookie
                ngx.header["Set-Cookie"] = "proxy_session=" .. session_cookie_value .. "; Path=/; HttpOnly; Secure; SameSite=Strict; Max-Age=" .. session_max_age
                ngx.header["Cache-Control"] = "no-store"
                ngx.header["Content-Type"] = "application/json"
                ngx.say('{"status":"ok"}')
            }
        }

        # =====================================================
        # INTERNAL HTPASSWD CHECK - Validates user exists
        # =====================================================
        location /internal-htpasswd-check {
            internal;
            content_by_lua_block {
                local username = ngx.var.username_to_check
                if not username then
                    ngx.exit(ngx.HTTP_BAD_REQUEST)
                    return
                end
                
                -- Read htpasswd file and check if user exists
                local file = io.open("/etc/nginx/.htpasswd", "r")
                if not file then
                    ngx.exit(ngx.HTTP_INTERNAL_SERVER_ERROR)
                    return
                end
                
                local found = false
                for line in file:lines() do
                    local user = line:match("^([^:]+):")
                    if user == username then
                        found = true
                        break
                    end
                end
                file:close()
                
                if found then
                    ngx.exit(ngx.HTTP_OK)
                else
                    ngx.exit(ngx.HTTP_UNAUTHORIZED)
                end
            }
        }

        # =====================================================
        # SESSION VALIDATION (internal)
        # =====================================================
        location = /proxy-check-session {
            internal;
            content_by_lua_block {
                local cookie = ngx.var.cookie_proxy_session
                if not cookie or cookie == "" then
                    ngx.exit(ngx.HTTP_UNAUTHORIZED)
                    return
                end
                
                -- Parse cookie: username:timestamp:signature
                local username, timestamp, signature = cookie:match("^([^:]+):([^:]+):([^:]+)$")
                if not username or not timestamp or not signature then
                    ngx.exit(ngx.HTTP_UNAUTHORIZED)
                    return
                end
                
                -- Verify signature with constant-time comparison
                local resty_sha256 = require "resty.sha256"
                local str = require "resty.string"
                local secret = read_secret_file("/etc/nginx/secrets/session_secret")
                
                local data = username .. ":" .. timestamp
                local sha256 = resty_sha256:new()
                sha256:update(secret .. data)
                local expected_signature = str.to_hex(sha256:final())
                
                -- Constant-time comparison to prevent timing attacks
                local function secure_compare(a, b)
                    if #a ~= #b then return false end
                    local result = 0
                    for i = 1, #a do
                        result = bit.bor(result, bit.bxor(string.byte(a, i), string.byte(b, i)))
                    end
                    return result == 0
                end
                
                if not secure_compare(signature, expected_signature) then
                    ngx.log(ngx.WARN, "Invalid session signature for user: ", username)
                    ngx.exit(ngx.HTTP_UNAUTHORIZED)
                    return
                end
                
                -- Check expiry
                local max_age = _G.SESSION_MAX_AGE
                local session_age = ngx.now() - tonumber(timestamp)
                if session_age > max_age then
                    ngx.log(ngx.INFO, "Expired session for user: ", username)
                    ngx.exit(ngx.HTTP_UNAUTHORIZED)
                    return
                end
                
                -- Valid session - set header for downstream
                ngx.req.set_header("X-Proxy-User", username)
                ngx.exit(ngx.HTTP_OK)
            }
        }

        # =====================================================
        # MAIN PROXY - Cookie OR Basic Auth
        # =====================================================
        location / {
            # Try cookie auth first
            auth_request /proxy-check-session;
            auth_request_set $session_user $upstream_http_x_proxy_user;
            
            # If cookie auth fails, try basic auth or redirect
            error_page 401 = @try_basic_auth;

            # Proxy settings
            proxy_pass $UPSTREAM_HOST;
            proxy_set_header Host $host;
            proxy_set_header X-Real-IP $remote_addr;
            proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
            proxy_set_header X-Forwarded-Proto $scheme;
            proxy_set_header X-Proxy-User $session_user;

            # WebSocket support
            proxy_http_version 1.1;
            proxy_set_header Upgrade $http_upgrade;
            proxy_set_header Connection $connection_upgrade;
            proxy_read_timeout 86400s;
            proxy_send_timeout 86400s;
            proxy_buffering off;
        }

        # =====================================================
        # BASIC AUTH FALLBACK
        # =====================================================
        location @try_basic_auth {
            # Check if Basic Auth header is present
            if ($has_basic_auth = 0) {
                # No Basic Auth header - redirect to login with redirect parameter
                return 303 /proxy-login?redirect=$request_uri;
            }

            # Has Basic Auth header - validate against htpasswd
            auth_basic "Restricted";
            auth_basic_user_file /etc/nginx/.htpasswd;

            # If we get here, Basic Auth succeeded
            proxy_pass $UPSTREAM_HOST;
            proxy_set_header Host $host;
            proxy_set_header X-Real-IP $remote_addr;
            proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
            proxy_set_header X-Forwarded-Proto $scheme;
            proxy_set_header X-Proxy-User $remote_user;

            # WebSocket support
            proxy_http_version 1.1;
            proxy_set_header Upgrade $http_upgrade;
            proxy_set_header Connection $connection_upgrade;
            proxy_read_timeout 86400s;
            proxy_send_timeout 86400s;
            proxy_buffering off;
        }
    }
}
